## golocker
尝试了几种锁的实现

### 递归锁 `RecursiveLocker`

严格上讲递归锁只是互斥锁的一个特例，同样只能有一个线程访问该对象，
但允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。

### 自旋锁 `SpinLocker`

同互斥锁不同的是在锁操作需要等待的时候并不是睡眠等待唤醒，
而是循环检测保持者已经释放了锁，
这样做的好处是节省了线程从睡眠状态到唤醒之间内核会产生的消耗，
在加锁时间短暂的环境下这点会提高很大效率。

### 顺序锁 `SeqLocker`

顺序锁也是对读写锁的一种优化，对于顺序锁，读者绝不会被写者阻塞，也就说，读者可以在写者对被顺序锁保护的共享资源进行写操作时仍然可以继续读，而不必等待写者完成写操作，写者也不需要等待所有读者完成读操作才去进行写操作。但是，写者与写者之间仍然是互斥的，即如果有写者在进行写操作，其他写者必须自旋在那里，直到写者释放了顺序锁。
这种锁有一个限制，它必须要求被保护的共享资源不含有指针，因为写者可能使得指针失效，但读者如果正要访问该指针，将导致OOPs。
如果读者在读操作期间，写者已经发生了写操作，那么，读者必须重新读取数据，以便确保得到的数据是完整的。
这种锁对于读写同时进行的概率比较小的情况，性能是非常好的，而且它允许读写同时进行，因而更大地提高了并发性。


### 计数锁 `CountLocker`
计数锁的含义是，锁持有者可以加一定次数的锁，但必须以相同次数的解锁操作，才能抵消本次加锁的效用
这是一种比较常见的使用锁方式。

### 组锁 `GroupLocker`
组锁的含义是，锁的持有者允许，其他线程进入锁持有者锁保护的临界区域。
